
reflct  反射
serial	连续的
synchronized 同步
volitae	不稳定的
一.多线程
	1.synchronized
		线程解锁前,必须把共享变量的最新值刷新到主内存中
		线程加锁时,将清空工作内存中共享变量的值,在使用时需要从主内存重新读取
		加锁和解锁必须是同一把锁
		步骤:
			获得互斥锁 清空工作内存 拷贝主内存的变量副本 执行代码 刷向共享变量的值到主内存 释放互斥锁
		不可见的原因
			线程的交叉执行					原子性
			重排序结合线程交叉执行			原子性
			共享变量未及时更新				可见性
		synchronized可以保证原子性和可见性
	2.volatile
		禁止指令的重排序
		加入内存屏障,每次读写都刷新主内存
		需求:
			对变量的写入操作不依赖当前值
			改变量没有包含在具有其他变量的不变式中
	3.指令重排序
		编译器优化
		指令级并行重排序(处理器优化)
		内存系统的重排序(处理器优化)
		as-if-serial:无论如何排序,程序的执行结果应该与代码的顺序一致(JAVA编译器,运行时和处理区都会保证在单线程下遵循as-if-serial语义)
	4.JDK提供的api
		ReentrantLock
		AtomicInterger

二.文件操作
	编码:
		GBK 中文占用两个字节,英文占用一个字节
		UTF-8 中文占用三个字节,英文占用一个字节
		UTF-16be 中文占用两个字节,英文占用两个字节
	java.io.File
		可以表示文件和目录,该类只保存文件信息
	RandomAccessFile 随机读写文件
		构造参数:文件 操作(rw) 

三.反射
	
	
	